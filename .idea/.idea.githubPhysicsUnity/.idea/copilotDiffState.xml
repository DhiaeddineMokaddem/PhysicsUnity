<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/yahya2/CustomCollisionSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/yahya2/CustomCollisionSystem.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;/// &lt;summary&gt;&#10;/// Système de détection et résolution de collisions personnalisé&#10;/// &lt;/summary&gt;&#10;public class CustomCollisionSystem&#10;{&#10;    public struct CollisionContact&#10;    {&#10;        public CustomRigidBody bodyA;&#10;        public CustomRigidBody bodyB;&#10;        public Vector3 point;&#10;        public Vector3 normal;&#10;        public float penetration;&#10;&#10;        public CollisionContact(CustomRigidBody a, CustomRigidBody b, Vector3 p, Vector3 n, float depth)&#10;        {&#10;            bodyA = a;&#10;            bodyB = b;&#10;            point = p;&#10;            normal = n;&#10;            penetration = depth;&#10;        }&#10;    }&#10;&#10;    private float restitution = 0.4f;&#10;    private float friction = 0.3f;&#10;    private List&lt;CollisionContact&gt; contacts = new List&lt;CollisionContact&gt;();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Détecte les collisions entre deux boîtes orientées&#10;    /// &lt;/summary&gt;&#10;    public bool DetectBoxCollision(CustomRigidBody boxA, CustomRigidBody boxB, out CollisionContact contact)&#10;    {&#10;        contact = new CollisionContact();&#10;&#10;        Vector3 centerA = boxA.position;&#10;        Vector3 centerB = boxB.position;&#10;        Vector3 delta = centerB - centerA;&#10;&#10;        // Axes de séparation&#10;        Vector3[] axesA = new Vector3[] { boxA.GetRight(), boxA.GetUp(), boxA.GetForward() };&#10;        Vector3[] axesB = new Vector3[] { boxB.GetRight(), boxB.GetUp(), boxB.GetForward() };&#10;&#10;        Vector3 halfSizeA = boxA.size * 0.5f;&#10;        Vector3 halfSizeB = boxB.size * 0.5f;&#10;&#10;        float minPenetration = float.MaxValue;&#10;        Vector3 minAxis = Vector3.zero;&#10;&#10;        // Test des 15 axes de séparation (SAT)&#10;        // 6 axes des faces&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            if (!TestAxis(axesA[i], delta, halfSizeA[i], halfSizeB, axesB, ref minPenetration, ref minAxis))&#10;                return false;&#10;        }&#10;&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            if (!TestAxis(axesB[i], delta, ProjectOntoAxis(halfSizeA, axesA, axesB[i]), halfSizeB[i], ref minPenetration, ref minAxis))&#10;                return false;&#10;        }&#10;&#10;        // 9 axes des arêtes (produits vectoriels)&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            for (int j = 0; j &lt; 3; j++)&#10;            {&#10;                Vector3 axis = Vector3.Cross(axesA[i], axesB[j]);&#10;                if (axis.sqrMagnitude &lt; 0.0001f) continue;&#10;                axis.Normalize();&#10;&#10;                float projA = ProjectOntoAxis(halfSizeA, axesA, axis);&#10;                float projB = ProjectOntoAxis(halfSizeB, axesB, axis);&#10;&#10;                if (!TestAxis(axis, delta, projA, projB, ref minPenetration, ref minAxis))&#10;                    return false;&#10;            }&#10;        }&#10;&#10;        // S'assurer que la normale pointe de A vers B&#10;        if (Vector3.Dot(minAxis, delta) &lt; 0)&#10;            minAxis = -minAxis;&#10;&#10;        Vector3 contactPoint = centerA + delta * 0.5f;&#10;        contact = new CollisionContact(boxA, boxB, contactPoint, minAxis, minPenetration);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Teste un axe de séparation&#10;    /// &lt;/summary&gt;&#10;    bool TestAxis(Vector3 axis, Vector3 delta, float projA, float projB, ref float minPenetration, ref Vector3 minAxis)&#10;    {&#10;        float distance = Mathf.Abs(Vector3.Dot(delta, axis));&#10;        float penetration = projA + projB - distance;&#10;&#10;        if (penetration &lt; -0.01f)&#10;            return false;&#10;&#10;        if (penetration &lt; minPenetration)&#10;        {&#10;            minPenetration = penetration;&#10;            minAxis = axis;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Projette une boîte sur un axe&#10;    /// &lt;/summary&gt;&#10;    float ProjectOntoAxis(Vector3 halfSize, Vector3[] axes, Vector3 axis)&#10;    {&#10;        return halfSize.x * Mathf.Abs(Vector3.Dot(axes[0], axis)) +&#10;               halfSize.y * Mathf.Abs(Vector3.Dot(axes[1], axis)) +&#10;               halfSize.z * Mathf.Abs(Vector3.Dot(axes[2], axis));&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Résout une collision avec impulsion&#10;    /// &lt;/summary&gt;&#10;    public void ResolveCollision(CollisionContact contact)&#10;    {&#10;        CustomRigidBody bodyA = contact.bodyA;&#10;        CustomRigidBody bodyB = contact.bodyB;&#10;&#10;        if ((bodyA.isStatic &amp;&amp; bodyB.isStatic) || bodyA == null || bodyB == null)&#10;            return;&#10;&#10;        // Séparation des corps&#10;        ResolvePenetration(contact);&#10;&#10;        // Vitesses au point de contact&#10;        Vector3 velA = bodyA.isStatic ? Vector3.zero : bodyA.GetVelocityAtPoint(contact.point);&#10;        Vector3 velB = bodyB.isStatic ? Vector3.zero : bodyB.GetVelocityAtPoint(contact.point);&#10;        Vector3 relativeVel = velB - velA;&#10;&#10;        float velAlongNormal = Vector3.Dot(relativeVel, contact.normal);&#10;&#10;        // Ne pas résoudre si les objets s'éloignent&#10;        if (velAlongNormal &gt; 0)&#10;            return;&#10;&#10;        // Calcul de l'impulsion&#10;        float e = restitution;&#10;        float invMassA = bodyA.isStatic ? 0 : 1.0f / bodyA.mass;&#10;        float invMassB = bodyB.isStatic ? 0 : 1.0f / bodyB.mass;&#10;&#10;        Vector3 rA = contact.point - bodyA.position;&#10;        Vector3 rB = contact.point - bodyB.position;&#10;&#10;        Vector3 raCrossN = Vector3.Cross(rA, contact.normal);&#10;        Vector3 rbCrossN = Vector3.Cross(rB, contact.normal);&#10;&#10;        float angularEffect = 0;&#10;        if (!bodyA.isStatic)&#10;        {&#10;            Matrix4x4 invInertiaA = GetWorldInertiaInverse(bodyA);&#10;            Vector3 temp = MultiplyMatrixVector(invInertiaA, raCrossN);&#10;            angularEffect += Vector3.Dot(contact.normal, Vector3.Cross(temp, rA));&#10;        }&#10;        if (!bodyB.isStatic)&#10;        {&#10;            Matrix4x4 invInertiaB = GetWorldInertiaInverse(bodyB);&#10;            Vector3 temp = MultiplyMatrixVector(invInertiaB, rbCrossN);&#10;            angularEffect += Vector3.Dot(contact.normal, Vector3.Cross(temp, rB));&#10;        }&#10;&#10;        float j = -(1 + e) * velAlongNormal;&#10;        j /= (invMassA + invMassB + angularEffect);&#10;&#10;        Vector3 impulse = contact.normal * j;&#10;&#10;        // Appliquer l'impulsion&#10;        if (!bodyA.isStatic)&#10;        {&#10;            bodyA.velocity -= impulse * invMassA;&#10;            bodyA.angularVelocity -= MultiplyMatrixVector(GetWorldInertiaInverse(bodyA), raCrossN) * j;&#10;        }&#10;&#10;        if (!bodyB.isStatic)&#10;        {&#10;            bodyB.velocity += impulse * invMassB;&#10;            bodyB.angularVelocity += MultiplyMatrixVector(GetWorldInertiaInverse(bodyB), rbCrossN) * j;&#10;        }&#10;&#10;        // Friction&#10;        ApplyFriction(contact, impulse.magnitude);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Résout la pénétration&#10;    /// &lt;/summary&gt;&#10;    void ResolvePenetration(CollisionContact contact)&#10;    {&#10;        if (contact.penetration &lt;= 0.001f) return;&#10;&#10;        float invMassA = contact.bodyA.isStatic ? 0 : 1.0f / contact.bodyA.mass;&#10;        float invMassB = contact.bodyB.isStatic ? 0 : 1.0f / contact.bodyB.mass;&#10;        float totalInvMass = invMassA + invMassB;&#10;&#10;        if (totalInvMass &lt;= 0) return;&#10;&#10;        Vector3 correction = contact.normal * (contact.penetration * 1.01f) / totalInvMass;&#10;&#10;        if (!contact.bodyA.isStatic)&#10;        {&#10;            contact.bodyA.position -= correction * invMassA;&#10;            contact.bodyA.transform.position = contact.bodyA.position;&#10;        }&#10;&#10;        if (!contact.bodyB.isStatic)&#10;        {&#10;            contact.bodyB.position += correction * invMassB;&#10;            contact.bodyB.transform.position = contact.bodyB.position;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Applique la friction&#10;    /// &lt;/summary&gt;&#10;    void ApplyFriction(CollisionContact contact, float normalImpulseMag)&#10;    {&#10;        Vector3 velA = contact.bodyA.isStatic ? Vector3.zero : contact.bodyA.GetVelocityAtPoint(contact.point);&#10;        Vector3 velB = contact.bodyB.isStatic ? Vector3.zero : contact.bodyB.GetVelocityAtPoint(contact.point);&#10;        Vector3 relativeVel = velB - velA;&#10;&#10;        Vector3 tangent = relativeVel - contact.normal * Vector3.Dot(relativeVel, contact.normal);&#10;        if (tangent.sqrMagnitude &lt; 0.0001f) return;&#10;&#10;        tangent.Normalize();&#10;&#10;        float invMassA = contact.bodyA.isStatic ? 0 : 1.0f / contact.bodyA.mass;&#10;        float invMassB = contact.bodyB.isStatic ? 0 : 1.0f / contact.bodyB.mass;&#10;&#10;        float jt = -Vector3.Dot(relativeVel, tangent);&#10;        jt /= (invMassA + invMassB);&#10;&#10;        Vector3 frictionImpulse;&#10;        if (Mathf.Abs(jt) &lt; normalImpulseMag * friction)&#10;            frictionImpulse = tangent * jt;&#10;        else&#10;            frictionImpulse = tangent * -normalImpulseMag * friction;&#10;&#10;        if (!contact.bodyA.isStatic)&#10;            contact.bodyA.velocity -= frictionImpulse * invMassA;&#10;&#10;        if (!contact.bodyB.isStatic)&#10;            contact.bodyB.velocity += frictionImpulse * invMassB;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Helpers pour les calculs matriciels&#10;    /// &lt;/summary&gt;&#10;    Matrix4x4 GetWorldInertiaInverse(CustomRigidBody body)&#10;    {&#10;        // Cette méthode devrait être accessible depuis CustomRigidBody&#10;        // Pour simplifier, on recalcule ici&#10;        Matrix4x4 R = Matrix4x4.Rotate(body.rotation);&#10;        Matrix4x4 Rt = TransposeMatrix(R);&#10;        &#10;        // Inertie inverse locale (simple pour une boîte)&#10;        float m = body.mass;&#10;        float w = body.size.x, h = body.size.y, d = body.size.z;&#10;        float Ixx = (m / 12.0f) * (h * h + d * d);&#10;        float Iyy = (m / 12.0f) * (w * w + d * d);&#10;        float Izz = (m / 12.0f) * (w * w + h * h);&#10;        &#10;        Matrix4x4 IInv = Matrix4x4.zero;&#10;        IInv.m00 = 1.0f / Ixx;&#10;        IInv.m11 = 1.0f / Iyy;&#10;        IInv.m22 = 1.0f / Izz;&#10;        IInv.m33 = 1;&#10;&#10;        return MultiplyMatrices(MultiplyMatrices(R, IInv), Rt);&#10;    }&#10;&#10;    Matrix4x4 MultiplyMatrices(Matrix4x4 a, Matrix4x4 b)&#10;    {&#10;        Matrix4x4 result = Matrix4x4.zero;&#10;        for (int i = 0; i &lt; 3; i++)&#10;            for (int j = 0; j &lt; 3; j++)&#10;                result[i, j] = a[i, 0] * b[0, j] + a[i, 1] * b[1, j] + a[i, 2] * b[2, j];&#10;        result.m33 = 1;&#10;        return result;&#10;    }&#10;&#10;    Matrix4x4 TransposeMatrix(Matrix4x4 m)&#10;    {&#10;        Matrix4x4 result = Matrix4x4.zero;&#10;        for (int i = 0; i &lt; 3; i++)&#10;            for (int j = 0; j &lt; 3; j++)&#10;                result[i, j] = m[j, i];&#10;        result.m33 = 1;&#10;        return result;&#10;    }&#10;&#10;    Vector3 MultiplyMatrixVector(Matrix4x4 m, Vector3 v)&#10;    {&#10;        return new Vector3(&#10;            m.m00 * v.x + m.m01 * v.y + m.m02 * v.z,&#10;            m.m10 * v.x + m.m11 * v.y + m.m12 * v.z,&#10;            m.m20 * v.x + m.m21 * v.y + m.m22 * v.z&#10;        );&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;/// &lt;summary&gt;&#10;/// Système de détection et résolution de collisions personnalisé&#10;/// &lt;/summary&gt;&#10;public class CustomCollisionSystem&#10;{&#10;    public struct CollisionContact&#10;    {&#10;        public CustomRigidBody bodyA;&#10;        public CustomRigidBody bodyB;&#10;        public Vector3 point;&#10;        public Vector3 normal;&#10;        public float penetration;&#10;&#10;        public CollisionContact(CustomRigidBody a, CustomRigidBody b, Vector3 p, Vector3 n, float depth)&#10;        {&#10;            bodyA = a;&#10;            bodyB = b;&#10;            point = p;&#10;            normal = n;&#10;            penetration = depth;&#10;        }&#10;    }&#10;&#10;    private float restitution = 0.4f;&#10;    private float friction = 0.3f;&#10;    private List&lt;CollisionContact&gt; contacts = new List&lt;CollisionContact&gt;();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Détecte les collisions entre deux boîtes orientées&#10;    /// &lt;/summary&gt;&#10;    public bool DetectBoxCollision(CustomRigidBody boxA, CustomRigidBody boxB, out CollisionContact contact)&#10;    {&#10;        contact = new CollisionContact();&#10;&#10;        Vector3 centerA = boxA.position;&#10;        Vector3 centerB = boxB.position;&#10;        Vector3 delta = centerB - centerA;&#10;&#10;        // Axes de séparation&#10;        Vector3[] axesA = new Vector3[] { boxA.GetRight(), boxA.GetUp(), boxA.GetForward() };&#10;        Vector3[] axesB = new Vector3[] { boxB.GetRight(), boxB.GetUp(), boxB.GetForward() };&#10;&#10;        Vector3 halfSizeA = boxA.size * 0.5f;&#10;        Vector3 halfSizeB = boxB.size * 0.5f;&#10;&#10;        float minPenetration = float.MaxValue;&#10;        Vector3 minAxis = Vector3.zero;&#10;&#10;        // Test des 15 axes de séparation (SAT)&#10;        // 6 axes des faces&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            if (!TestAxis(axesA[i], delta, halfSizeA[i], ProjectOntoAxis(halfSizeB, axesB, axesA[i]), ref minPenetration, ref minAxis))&#10;                return false;&#10;        }&#10;&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            if (!TestAxis(axesB[i], delta, ProjectOntoAxis(halfSizeA, axesA, axesB[i]), halfSizeB[i], ref minPenetration, ref minAxis))&#10;                return false;&#10;        }&#10;&#10;        // 9 axes des arêtes (produits vectoriels)&#10;        for (int i = 0; i &lt; 3; i++)&#10;        {&#10;            for (int j = 0; j &lt; 3; j++)&#10;            {&#10;                Vector3 axis = Vector3.Cross(axesA[i], axesB[j]);&#10;                if (axis.sqrMagnitude &lt; 0.0001f) continue;&#10;                axis.Normalize();&#10;&#10;                float projA = ProjectOntoAxis(halfSizeA, axesA, axis);&#10;                float projB = ProjectOntoAxis(halfSizeB, axesB, axis);&#10;&#10;                if (!TestAxis(axis, delta, projA, projB, ref minPenetration, ref minAxis))&#10;                    return false;&#10;            }&#10;        }&#10;&#10;        // S'assurer que la normale pointe de A vers B&#10;        if (Vector3.Dot(minAxis, delta) &lt; 0)&#10;            minAxis = -minAxis;&#10;&#10;        Vector3 contactPoint = centerA + delta * 0.5f;&#10;        contact = new CollisionContact(boxA, boxB, contactPoint, minAxis, minPenetration);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Teste un axe de séparation&#10;    /// &lt;/summary&gt;&#10;    bool TestAxis(Vector3 axis, Vector3 delta, float projA, float projB, ref float minPenetration, ref Vector3 minAxis)&#10;    {&#10;        float distance = Mathf.Abs(Vector3.Dot(delta, axis));&#10;        float penetration = projA + projB - distance;&#10;&#10;        if (penetration &lt; -0.01f)&#10;            return false;&#10;&#10;        if (penetration &lt; minPenetration)&#10;        {&#10;            minPenetration = penetration;&#10;            minAxis = axis;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Projette une boîte sur un axe&#10;    /// &lt;/summary&gt;&#10;    float ProjectOntoAxis(Vector3 halfSize, Vector3[] axes, Vector3 axis)&#10;    {&#10;        return halfSize.x * Mathf.Abs(Vector3.Dot(axes[0], axis)) +&#10;               halfSize.y * Mathf.Abs(Vector3.Dot(axes[1], axis)) +&#10;               halfSize.z * Mathf.Abs(Vector3.Dot(axes[2], axis));&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Résout une collision avec impulsion&#10;    /// &lt;/summary&gt;&#10;    public void ResolveCollision(CollisionContact contact)&#10;    {&#10;        CustomRigidBody bodyA = contact.bodyA;&#10;        CustomRigidBody bodyB = contact.bodyB;&#10;&#10;        if ((bodyA.isStatic &amp;&amp; bodyB.isStatic) || bodyA == null || bodyB == null)&#10;            return;&#10;&#10;        // Séparation des corps&#10;        ResolvePenetration(contact);&#10;&#10;        // Vitesses au point de contact&#10;        Vector3 velA = bodyA.isStatic ? Vector3.zero : bodyA.GetVelocityAtPoint(contact.point);&#10;        Vector3 velB = bodyB.isStatic ? Vector3.zero : bodyB.GetVelocityAtPoint(contact.point);&#10;        Vector3 relativeVel = velB - velA;&#10;&#10;        float velAlongNormal = Vector3.Dot(relativeVel, contact.normal);&#10;&#10;        // Ne pas résoudre si les objets s'éloignent&#10;        if (velAlongNormal &gt; 0)&#10;            return;&#10;&#10;        // Calcul de l'impulsion&#10;        float e = restitution;&#10;        float invMassA = bodyA.isStatic ? 0 : 1.0f / bodyA.mass;&#10;        float invMassB = bodyB.isStatic ? 0 : 1.0f / bodyB.mass;&#10;&#10;        Vector3 rA = contact.point - bodyA.position;&#10;        Vector3 rB = contact.point - bodyB.position;&#10;&#10;        Vector3 raCrossN = Vector3.Cross(rA, contact.normal);&#10;        Vector3 rbCrossN = Vector3.Cross(rB, contact.normal);&#10;&#10;        float angularEffect = 0;&#10;        if (!bodyA.isStatic)&#10;        {&#10;            Matrix4x4 invInertiaA = GetWorldInertiaInverse(bodyA);&#10;            Vector3 temp = MultiplyMatrixVector(invInertiaA, raCrossN);&#10;            angularEffect += Vector3.Dot(contact.normal, Vector3.Cross(temp, rA));&#10;        }&#10;        if (!bodyB.isStatic)&#10;        {&#10;            Matrix4x4 invInertiaB = GetWorldInertiaInverse(bodyB);&#10;            Vector3 temp = MultiplyMatrixVector(invInertiaB, rbCrossN);&#10;            angularEffect += Vector3.Dot(contact.normal, Vector3.Cross(temp, rB));&#10;        }&#10;&#10;        float j = -(1 + e) * velAlongNormal;&#10;        j /= (invMassA + invMassB + angularEffect);&#10;&#10;        Vector3 impulse = contact.normal * j;&#10;&#10;        // Appliquer l'impulsion&#10;        if (!bodyA.isStatic)&#10;        {&#10;            bodyA.velocity -= impulse * invMassA;&#10;            bodyA.angularVelocity -= MultiplyMatrixVector(GetWorldInertiaInverse(bodyA), raCrossN) * j;&#10;        }&#10;&#10;        if (!bodyB.isStatic)&#10;        {&#10;            bodyB.velocity += impulse * invMassB;&#10;            bodyB.angularVelocity += MultiplyMatrixVector(GetWorldInertiaInverse(bodyB), rbCrossN) * j;&#10;        }&#10;&#10;        // Friction&#10;        ApplyFriction(contact, impulse.magnitude);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Résout la pénétration&#10;    /// &lt;/summary&gt;&#10;    void ResolvePenetration(CollisionContact contact)&#10;    {&#10;        if (contact.penetration &lt;= 0.001f) return;&#10;&#10;        float invMassA = contact.bodyA.isStatic ? 0 : 1.0f / contact.bodyA.mass;&#10;        float invMassB = contact.bodyB.isStatic ? 0 : 1.0f / contact.bodyB.mass;&#10;        float totalInvMass = invMassA + invMassB;&#10;&#10;        if (totalInvMass &lt;= 0) return;&#10;&#10;        Vector3 correction = contact.normal * (contact.penetration * 1.01f) / totalInvMass;&#10;&#10;        if (!contact.bodyA.isStatic)&#10;        {&#10;            contact.bodyA.position -= correction * invMassA;&#10;            contact.bodyA.transform.position = contact.bodyA.position;&#10;        }&#10;&#10;        if (!contact.bodyB.isStatic)&#10;        {&#10;            contact.bodyB.position += correction * invMassB;&#10;            contact.bodyB.transform.position = contact.bodyB.position;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Applique la friction&#10;    /// &lt;/summary&gt;&#10;    void ApplyFriction(CollisionContact contact, float normalImpulseMag)&#10;    {&#10;        Vector3 velA = contact.bodyA.isStatic ? Vector3.zero : contact.bodyA.GetVelocityAtPoint(contact.point);&#10;        Vector3 velB = contact.bodyB.isStatic ? Vector3.zero : contact.bodyB.GetVelocityAtPoint(contact.point);&#10;        Vector3 relativeVel = velB - velA;&#10;&#10;        Vector3 tangent = relativeVel - contact.normal * Vector3.Dot(relativeVel, contact.normal);&#10;        if (tangent.sqrMagnitude &lt; 0.0001f) return;&#10;&#10;        tangent.Normalize();&#10;&#10;        float invMassA = contact.bodyA.isStatic ? 0 : 1.0f / contact.bodyA.mass;&#10;        float invMassB = contact.bodyB.isStatic ? 0 : 1.0f / contact.bodyB.mass;&#10;&#10;        float jt = -Vector3.Dot(relativeVel, tangent);&#10;        jt /= (invMassA + invMassB);&#10;&#10;        Vector3 frictionImpulse;&#10;        if (Mathf.Abs(jt) &lt; normalImpulseMag * friction)&#10;            frictionImpulse = tangent * jt;&#10;        else&#10;            frictionImpulse = tangent * -normalImpulseMag * friction;&#10;&#10;        if (!contact.bodyA.isStatic)&#10;            contact.bodyA.velocity -= frictionImpulse * invMassA;&#10;&#10;        if (!contact.bodyB.isStatic)&#10;            contact.bodyB.velocity += frictionImpulse * invMassB;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Helpers pour les calculs matriciels&#10;    /// &lt;/summary&gt;&#10;    Matrix4x4 GetWorldInertiaInverse(CustomRigidBody body)&#10;    {&#10;        // Cette méthode devrait être accessible depuis CustomRigidBody&#10;        // Pour simplifier, on recalcule ici&#10;        Matrix4x4 R = Matrix4x4.Rotate(body.rotation);&#10;        Matrix4x4 Rt = TransposeMatrix(R);&#10;        &#10;        // Inertie inverse locale (simple pour une boîte)&#10;        float m = body.mass;&#10;        float w = body.size.x, h = body.size.y, d = body.size.z;&#10;        float Ixx = (m / 12.0f) * (h * h + d * d);&#10;        float Iyy = (m / 12.0f) * (w * w + d * d);&#10;        float Izz = (m / 12.0f) * (w * w + h * h);&#10;        &#10;        Matrix4x4 IInv = Matrix4x4.zero;&#10;        IInv.m00 = 1.0f / Ixx;&#10;        IInv.m11 = 1.0f / Iyy;&#10;        IInv.m22 = 1.0f / Izz;&#10;        IInv.m33 = 1;&#10;&#10;        return MultiplyMatrices(MultiplyMatrices(R, IInv), Rt);&#10;    }&#10;&#10;    Matrix4x4 MultiplyMatrices(Matrix4x4 a, Matrix4x4 b)&#10;    {&#10;        Matrix4x4 result = Matrix4x4.zero;&#10;        for (int i = 0; i &lt; 3; i++)&#10;            for (int j = 0; j &lt; 3; j++)&#10;                result[i, j] = a[i, 0] * b[0, j] + a[i, 1] * b[1, j] + a[i, 2] * b[2, j];&#10;        result.m33 = 1;&#10;        return result;&#10;    }&#10;&#10;    Matrix4x4 TransposeMatrix(Matrix4x4 m)&#10;    {&#10;        Matrix4x4 result = Matrix4x4.zero;&#10;        for (int i = 0; i &lt; 3; i++)&#10;            for (int j = 0; j &lt; 3; j++)&#10;                result[i, j] = m[j, i];&#10;        result.m33 = 1;&#10;        return result;&#10;    }&#10;&#10;    Vector3 MultiplyMatrixVector(Matrix4x4 m, Vector3 v)&#10;    {&#10;        return new Vector3(&#10;            m.m00 * v.x + m.m01 * v.y + m.m02 * v.z,&#10;            m.m10 * v.x + m.m11 * v.y + m.m12 * v.z,&#10;            m.m20 * v.x + m.m21 * v.y + m.m22 * v.z&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/yahya2/CustomMeshGenerator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/yahya2/CustomMeshGenerator.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Génère des maillages personnalisés par code mathématique pur&#10;/// &lt;/summary&gt;&#10;public static class CustomMeshGenerator&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Crée un cube avec dimensions personnalisées&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreateBox(Vector3 size)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomBox&quot;;&#10;&#10;        float x = size.x * 0.5f;&#10;        float y = size.y * 0.5f;&#10;        float z = size.z * 0.5f;&#10;&#10;        // 24 vertices (4 par face pour les normales correctes)&#10;        Vector3[] vertices = new Vector3[24]&#10;        {&#10;            // Face avant (z+)&#10;            new Vector3(-x, -y,  z), new Vector3( x, -y,  z), new Vector3( x,  y,  z), new Vector3(-x,  y,  z),&#10;            // Face arrière (z-)&#10;            new Vector3( x, -y, -z), new Vector3(-x, -y, -z), new Vector3(-x,  y, -z), new Vector3( x,  y, -z),&#10;            // Face gauche (x-)&#10;            new Vector3(-x, -y, -z), new Vector3(-x, -y,  z), new Vector3(-x,  y,  z), new Vector3(-x,  y, -z),&#10;            // Face droite (x+)&#10;            new Vector3( x, -y,  z), new Vector3( x, -y, -z), new Vector3( x,  y, -z), new Vector3( x,  y,  z),&#10;            // Face haut (y+)&#10;            new Vector3(-x,  y,  z), new Vector3( x,  y,  z), new Vector3( x,  y, -z), new Vector3(-x,  y, -z),&#10;            // Face bas (y-)&#10;            new Vector3(-x, -y, -z), new Vector3( x, -y, -z), new Vector3( x, -y,  z), new Vector3(-x, -y,  z)&#10;        };&#10;&#10;        // Normales&#10;        Vector3[] normals = new Vector3[24];&#10;        for (int i = 0; i &lt; 4; i++)&#10;        {&#10;            normals[i] = Vector3.forward;      // Face avant&#10;            normals[i + 4] = Vector3.back;     // Face arrière&#10;            normals[i + 8] = Vector3.left;     // Face gauche&#10;            normals[i + 12] = Vector3.right;   // Face droite&#10;            normals[i + 16] = Vector3.up;      // Face haut&#10;            normals[i + 20] = Vector3.down;    // Face bas&#10;        }&#10;&#10;        // UVs&#10;        Vector2[] uvs = new Vector2[24];&#10;        for (int i = 0; i &lt; 6; i++)&#10;        {&#10;            int offset = i * 4;&#10;            uvs[offset] = new Vector2(0, 0);&#10;            uvs[offset + 1] = new Vector2(1, 0);&#10;            uvs[offset + 2] = new Vector2(1, 1);&#10;            uvs[offset + 3] = new Vector2(0, 1);&#10;        }&#10;&#10;        // Triangles (2 par face, 6 faces)&#10;        int[] triangles = new int[36];&#10;        for (int i = 0; i &lt; 6; i++)&#10;        {&#10;            int offset = i * 4;&#10;            int triOffset = i * 6;&#10;            &#10;            triangles[triOffset] = offset;&#10;            triangles[triOffset + 1] = offset + 2;&#10;            triangles[triOffset + 2] = offset + 1;&#10;            &#10;            triangles[triOffset + 3] = offset;&#10;            triangles[triOffset + 4] = offset + 3;&#10;            triangles[triOffset + 5] = offset + 2;&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un plan horizontal&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreatePlane(float width, float depth, int subdivisions = 1)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomPlane&quot;;&#10;&#10;        int vertCountX = subdivisions + 2;&#10;        int vertCountZ = subdivisions + 2;&#10;        int vertCount = vertCountX * vertCountZ;&#10;&#10;        Vector3[] vertices = new Vector3[vertCount];&#10;        Vector3[] normals = new Vector3[vertCount];&#10;        Vector2[] uvs = new Vector2[vertCount];&#10;&#10;        float halfW = width * 0.5f;&#10;        float halfD = depth * 0.5f;&#10;&#10;        // Générer les vertices&#10;        int vertIndex = 0;&#10;        for (int z = 0; z &lt; vertCountZ; z++)&#10;        {&#10;            for (int x = 0; x &lt; vertCountX; x++)&#10;            {&#10;                float xPos = -halfW + (width * x / (float)(vertCountX - 1));&#10;                float zPos = -halfD + (depth * z / (float)(vertCountZ - 1));&#10;                &#10;                vertices[vertIndex] = new Vector3(xPos, 0, zPos);&#10;                normals[vertIndex] = Vector3.up;&#10;                uvs[vertIndex] = new Vector2((float)x / (vertCountX - 1), (float)z / (vertCountZ - 1));&#10;                &#10;                vertIndex++;&#10;            }&#10;        }&#10;&#10;        // Générer les triangles&#10;        int triCount = (vertCountX - 1) * (vertCountZ - 1) * 6;&#10;        int[] triangles = new int[triCount];&#10;        int triIndex = 0;&#10;&#10;        for (int z = 0; z &lt; vertCountZ - 1; z++)&#10;        {&#10;            for (int x = 0; x &lt; vertCountX - 1; x++)&#10;            {&#10;                int i = z * vertCountX + x;&#10;                &#10;                // Premier triangle&#10;                triangles[triIndex++] = i;&#10;                triangles[triIndex++] = i + vertCountX;&#10;                triangles[triIndex++] = i + 1;&#10;                &#10;                // Second triangle&#10;                triangles[triIndex++] = i + 1;&#10;                triangles[triIndex++] = i + vertCountX;&#10;                triangles[triIndex++] = i + vertCountX + 1;&#10;            }&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un cylindre (pour les poteaux)&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreateCylinder(float radius, float height, int segments = 16)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomCylinder&quot;;&#10;&#10;        int vertCount = (segments + 1) * 2 + segments * 2;&#10;        Vector3[] vertices = new Vector3[vertCount];&#10;        Vector3[] normals = new Vector3[vertCount];&#10;        Vector2[] uvs = new Vector2[vertCount];&#10;&#10;        float halfH = height * 0.5f;&#10;        int vertIndex = 0;&#10;&#10;        // Cercle du bas et du haut&#10;        for (int ring = 0; ring &lt; 2; ring++)&#10;        {&#10;            float y = (ring == 0) ? -halfH : halfH;&#10;            &#10;            for (int i = 0; i &lt;= segments; i++)&#10;            {&#10;                float angle = (float)i / segments * Mathf.PI * 2f;&#10;                float x = Mathf.Cos(angle) * radius;&#10;                float z = Mathf.Sin(angle) * radius;&#10;                &#10;                vertices[vertIndex] = new Vector3(x, y, z);&#10;                normals[vertIndex] = new Vector3(x, 0, z).normalized;&#10;                uvs[vertIndex] = new Vector2((float)i / segments, ring);&#10;                vertIndex++;&#10;            }&#10;        }&#10;&#10;        // Caps (centres + bords)&#10;        int capCenterBottom = vertIndex;&#10;        vertices[vertIndex] = new Vector3(0, -halfH, 0);&#10;        normals[vertIndex] = Vector3.down;&#10;        uvs[vertIndex++] = new Vector2(0.5f, 0.5f);&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            float angle = (float)i / segments * Mathf.PI * 2f;&#10;            float x = Mathf.Cos(angle) * radius;&#10;            float z = Mathf.Sin(angle) * radius;&#10;            &#10;            vertices[vertIndex] = new Vector3(x, -halfH, z);&#10;            normals[vertIndex] = Vector3.down;&#10;            uvs[vertIndex++] = new Vector2(0.5f + x / (radius * 2), 0.5f + z / (radius * 2));&#10;        }&#10;&#10;        int capCenterTop = vertIndex;&#10;        vertices[vertIndex] = new Vector3(0, halfH, 0);&#10;        normals[vertIndex] = Vector3.up;&#10;        uvs[vertIndex++] = new Vector2(0.5f, 0.5f);&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            float angle = (float)i / segments * Mathf.PI * 2f;&#10;            float x = Mathf.Cos(angle) * radius;&#10;            float z = Mathf.Sin(angle) * radius;&#10;            &#10;            vertices[vertIndex] = new Vector3(x, halfH, z);&#10;            normals[vertIndex] = Vector3.up;&#10;            uvs[vertIndex++] = new Vector2(0.5f + x / (radius * 2), 0.5f + z / (radius * 2));&#10;        }&#10;&#10;        // Triangles des côtés&#10;        int triCount = segments * 6 + segments * 6;&#10;        int[] triangles = new int[triCount];&#10;        int triIndex = 0;&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            int bottomCurrent = i;&#10;            int bottomNext = i + 1;&#10;            int topCurrent = (segments + 1) + i;&#10;            int topNext = (segments + 1) + i + 1;&#10;&#10;            triangles[triIndex++] = bottomCurrent;&#10;            triangles[triIndex++] = topCurrent;&#10;            triangles[triIndex++] = bottomNext;&#10;&#10;            triangles[triIndex++] = bottomNext;&#10;            triangles[triIndex++] = topCurrent;&#10;            triangles[triIndex++] = topNext;&#10;        }&#10;&#10;        // Triangles du cap bas&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            triangles[triIndex++] = capCenterBottom;&#10;            triangles[triIndex++] = capCenterBottom + 1 + ((i + 1) % segments);&#10;            triangles[triIndex++] = capCenterBottom + 1 + i;&#10;        }&#10;&#10;        // Triangles du cap haut&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            triangles[triIndex++] = capCenterTop;&#10;            triangles[triIndex++] = capCenterTop + 1 + i;&#10;            triangles[triIndex++] = capCenterTop + 1 + ((i + 1) % segments);&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un GameObject avec un maillage personnalisé&#10;    /// &lt;/summary&gt;&#10;    public static GameObject CreateMeshObject(string name, Mesh mesh, Material material, Vector3 position, Quaternion rotation)&#10;    {&#10;        GameObject obj = new GameObject(name);&#10;        obj.transform.position = position;&#10;        obj.transform.rotation = rotation;&#10;&#10;        MeshFilter meshFilter = obj.AddComponent&lt;MeshFilter&gt;();&#10;        meshFilter.mesh = mesh;&#10;&#10;        MeshRenderer renderer = obj.AddComponent&lt;MeshRenderer&gt;();&#10;        renderer.material = material;&#10;&#10;        return obj;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un matériau avec couleur&#10;    /// &lt;/summary&gt;&#10;    public static Material CreateColorMaterial(Color color)&#10;    {&#10;        Material mat = new Material(Shader.Find(&quot;Standard&quot;));&#10;        mat.color = color;&#10;        return mat;&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Génère des maillages personnalisés par code mathématique pur&#10;/// &lt;/summary&gt;&#10;public static class CustomMeshGenerator&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Crée un cube avec dimensions personnalisées&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreateBox(Vector3 size)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomBox&quot;;&#10;&#10;        float x = size.x * 0.5f;&#10;        float y = size.y * 0.5f;&#10;        float z = size.z * 0.5f;&#10;&#10;        // 24 vertices (4 par face pour les normales correctes)&#10;        Vector3[] vertices = new Vector3[24]&#10;        {&#10;            // Face avant (z+)&#10;            new Vector3(-x, -y,  z), new Vector3( x, -y,  z), new Vector3( x,  y,  z), new Vector3(-x,  y,  z),&#10;            // Face arrière (z-)&#10;            new Vector3( x, -y, -z), new Vector3(-x, -y, -z), new Vector3(-x,  y, -z), new Vector3( x,  y, -z),&#10;            // Face gauche (x-)&#10;            new Vector3(-x, -y, -z), new Vector3(-x, -y,  z), new Vector3(-x,  y,  z), new Vector3(-x,  y, -z),&#10;            // Face droite (x+)&#10;            new Vector3( x, -y,  z), new Vector3( x, -y, -z), new Vector3( x,  y, -z), new Vector3( x,  y,  z),&#10;            // Face haut (y+)&#10;            new Vector3(-x,  y,  z), new Vector3( x,  y,  z), new Vector3( x,  y, -z), new Vector3(-x,  y, -z),&#10;            // Face bas (y-)&#10;            new Vector3(-x, -y, -z), new Vector3( x, -y, -z), new Vector3( x, -y,  z), new Vector3(-x, -y,  z)&#10;        };&#10;&#10;        // Normales&#10;        Vector3[] normals = new Vector3[24];&#10;        for (int i = 0; i &lt; 4; i++)&#10;        {&#10;            normals[i] = Vector3.forward;      // Face avant&#10;            normals[i + 4] = Vector3.back;     // Face arrière&#10;            normals[i + 8] = Vector3.left;     // Face gauche&#10;            normals[i + 12] = Vector3.right;   // Face droite&#10;            normals[i + 16] = Vector3.up;      // Face haut&#10;            normals[i + 20] = Vector3.down;    // Face bas&#10;        }&#10;&#10;        // UVs&#10;        Vector2[] uvs = new Vector2[24];&#10;        for (int i = 0; i &lt; 6; i++)&#10;        {&#10;            int offset = i * 4;&#10;            uvs[offset] = new Vector2(0, 0);&#10;            uvs[offset + 1] = new Vector2(1, 0);&#10;            uvs[offset + 2] = new Vector2(1, 1);&#10;            uvs[offset + 3] = new Vector2(0, 1);&#10;        }&#10;&#10;        // Triangles (2 par face, 6 faces)&#10;        int[] triangles = new int[36];&#10;        for (int i = 0; i &lt; 6; i++)&#10;        {&#10;            int offset = i * 4;&#10;            int triOffset = i * 6;&#10;            &#10;            triangles[triOffset] = offset;&#10;            triangles[triOffset + 1] = offset + 2;&#10;            triangles[triOffset + 2] = offset + 1;&#10;            &#10;            triangles[triOffset + 3] = offset;&#10;            triangles[triOffset + 4] = offset + 3;&#10;            triangles[triOffset + 5] = offset + 2;&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un plan horizontal&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreatePlane(float width, float depth, int subdivisions = 1)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomPlane&quot;;&#10;&#10;        int vertCountX = subdivisions + 2;&#10;        int vertCountZ = subdivisions + 2;&#10;        int vertCount = vertCountX * vertCountZ;&#10;&#10;        Vector3[] vertices = new Vector3[vertCount];&#10;        Vector3[] normals = new Vector3[vertCount];&#10;        Vector2[] uvs = new Vector2[vertCount];&#10;&#10;        float halfW = width * 0.5f;&#10;        float halfD = depth * 0.5f;&#10;&#10;        // Générer les vertices&#10;        int vertIndex = 0;&#10;        for (int z = 0; z &lt; vertCountZ; z++)&#10;        {&#10;            for (int x = 0; x &lt; vertCountX; x++)&#10;            {&#10;                float xPos = -halfW + (width * x / (float)(vertCountX - 1));&#10;                float zPos = -halfD + (depth * z / (float)(vertCountZ - 1));&#10;                &#10;                vertices[vertIndex] = new Vector3(xPos, 0, zPos);&#10;                normals[vertIndex] = Vector3.up;&#10;                uvs[vertIndex] = new Vector2((float)x / (vertCountX - 1), (float)z / (vertCountZ - 1));&#10;                &#10;                vertIndex++;&#10;            }&#10;        }&#10;&#10;        // Générer les triangles&#10;        int triCount = (vertCountX - 1) * (vertCountZ - 1) * 6;&#10;        int[] triangles = new int[triCount];&#10;        int triIndex = 0;&#10;&#10;        for (int z = 0; z &lt; vertCountZ - 1; z++)&#10;        {&#10;            for (int x = 0; x &lt; vertCountX - 1; x++)&#10;            {&#10;                int i = z * vertCountX + x;&#10;                &#10;                // Premier triangle&#10;                triangles[triIndex++] = i;&#10;                triangles[triIndex++] = i + vertCountX;&#10;                triangles[triIndex++] = i + 1;&#10;                &#10;                // Second triangle&#10;                triangles[triIndex++] = i + 1;&#10;                triangles[triIndex++] = i + vertCountX;&#10;                triangles[triIndex++] = i + vertCountX + 1;&#10;            }&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un cylindre (pour les poteaux)&#10;    /// &lt;/summary&gt;&#10;    public static Mesh CreateCylinder(float radius, float height, int segments = 16)&#10;    {&#10;        Mesh mesh = new Mesh();&#10;        mesh.name = &quot;CustomCylinder&quot;;&#10;&#10;        int vertCount = (segments + 1) * 2 + (segments + 1) * 2;&#10;        Vector3[] vertices = new Vector3[vertCount];&#10;        Vector3[] normals = new Vector3[vertCount];&#10;        Vector2[] uvs = new Vector2[vertCount];&#10;&#10;        float halfH = height * 0.5f;&#10;        int vertIndex = 0;&#10;&#10;        // Cercle du bas et du haut&#10;        for (int ring = 0; ring &lt; 2; ring++)&#10;        {&#10;            float y = (ring == 0) ? -halfH : halfH;&#10;            &#10;            for (int i = 0; i &lt;= segments; i++)&#10;            {&#10;                float angle = (float)i / segments * Mathf.PI * 2f;&#10;                float x = Mathf.Cos(angle) * radius;&#10;                float z = Mathf.Sin(angle) * radius;&#10;                &#10;                vertices[vertIndex] = new Vector3(x, y, z);&#10;                normals[vertIndex] = new Vector3(x, 0, z).normalized;&#10;                uvs[vertIndex] = new Vector2((float)i / segments, ring);&#10;                vertIndex++;&#10;            }&#10;        }&#10;&#10;        // Caps (centres + bords)&#10;        int capCenterBottom = vertIndex;&#10;        vertices[vertIndex] = new Vector3(0, -halfH, 0);&#10;        normals[vertIndex] = Vector3.down;&#10;        uvs[vertIndex++] = new Vector2(0.5f, 0.5f);&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            float angle = (float)i / segments * Mathf.PI * 2f;&#10;            float x = Mathf.Cos(angle) * radius;&#10;            float z = Mathf.Sin(angle) * radius;&#10;            &#10;            vertices[vertIndex] = new Vector3(x, -halfH, z);&#10;            normals[vertIndex] = Vector3.down;&#10;            uvs[vertIndex++] = new Vector2(0.5f + x / (radius * 2), 0.5f + z / (radius * 2));&#10;        }&#10;&#10;        int capCenterTop = vertIndex;&#10;        vertices[vertIndex] = new Vector3(0, halfH, 0);&#10;        normals[vertIndex] = Vector3.up;&#10;        uvs[vertIndex++] = new Vector2(0.5f, 0.5f);&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            float angle = (float)i / segments * Mathf.PI * 2f;&#10;            float x = Mathf.Cos(angle) * radius;&#10;            float z = Mathf.Sin(angle) * radius;&#10;            &#10;            vertices[vertIndex] = new Vector3(x, halfH, z);&#10;            normals[vertIndex] = Vector3.up;&#10;            uvs[vertIndex++] = new Vector2(0.5f + x / (radius * 2), 0.5f + z / (radius * 2));&#10;        }&#10;&#10;        // Triangles des côtés&#10;        int triCount = segments * 6 + segments * 6;&#10;        int[] triangles = new int[triCount];&#10;        int triIndex = 0;&#10;&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            int bottomCurrent = i;&#10;            int bottomNext = i + 1;&#10;            int topCurrent = (segments + 1) + i;&#10;            int topNext = (segments + 1) + i + 1;&#10;&#10;            triangles[triIndex++] = bottomCurrent;&#10;            triangles[triIndex++] = topCurrent;&#10;            triangles[triIndex++] = bottomNext;&#10;&#10;            triangles[triIndex++] = bottomNext;&#10;            triangles[triIndex++] = topCurrent;&#10;            triangles[triIndex++] = topNext;&#10;        }&#10;&#10;        // Triangles du cap bas&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            triangles[triIndex++] = capCenterBottom;&#10;            triangles[triIndex++] = capCenterBottom + 1 + ((i + 1) % segments);&#10;            triangles[triIndex++] = capCenterBottom + 1 + i;&#10;        }&#10;&#10;        // Triangles du cap haut&#10;        for (int i = 0; i &lt; segments; i++)&#10;        {&#10;            triangles[triIndex++] = capCenterTop;&#10;            triangles[triIndex++] = capCenterTop + 1 + i;&#10;            triangles[triIndex++] = capCenterTop + 1 + ((i + 1) % segments);&#10;        }&#10;&#10;        mesh.vertices = vertices;&#10;        mesh.normals = normals;&#10;        mesh.uv = uvs;&#10;        mesh.triangles = triangles;&#10;        mesh.RecalculateBounds();&#10;&#10;        return mesh;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un GameObject avec un maillage personnalisé&#10;    /// &lt;/summary&gt;&#10;    public static GameObject CreateMeshObject(string name, Mesh mesh, Material material, Vector3 position, Quaternion rotation)&#10;    {&#10;        GameObject obj = new GameObject(name);&#10;        obj.transform.position = position;&#10;        obj.transform.rotation = rotation;&#10;&#10;        MeshFilter meshFilter = obj.AddComponent&lt;MeshFilter&gt;();&#10;        meshFilter.mesh = mesh;&#10;&#10;        MeshRenderer renderer = obj.AddComponent&lt;MeshRenderer&gt;();&#10;        renderer.material = material;&#10;&#10;        return obj;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Crée un matériau avec couleur&#10;    /// &lt;/summary&gt;&#10;    public static Material CreateColorMaterial(Color color)&#10;    {&#10;        // Try multiple shader options for compatibility&#10;        Shader shader = Shader.Find(&quot;Universal Render Pipeline/Lit&quot;);&#10;        &#10;        if (shader == null)&#10;            shader = Shader.Find(&quot;Universal Render Pipeline/Simple Lit&quot;);&#10;        &#10;        if (shader == null)&#10;            shader = Shader.Find(&quot;Standard&quot;);&#10;        &#10;        if (shader == null)&#10;            shader = Shader.Find(&quot;Legacy Shaders/Diffuse&quot;);&#10;        &#10;        if (shader == null)&#10;        {&#10;            Debug.LogError(&quot;No URP or Standard shader found! Available shaders:&quot;);&#10;            foreach (var s in Resources.FindObjectsOfTypeAll&lt;Shader&gt;())&#10;                Debug.Log(&quot;  - &quot; + s.name);&#10;            &#10;            // Last resort: try Unlit&#10;            shader = Shader.Find(&quot;Unlit/Color&quot;);&#10;        }&#10;        &#10;        if (shader == null)&#10;        {&#10;            Debug.LogError(&quot;CRITICAL: No shader found at all!&quot;);&#10;            return null;&#10;        }&#10;        &#10;        Debug.Log(&quot;Using shader: &quot; + shader.name);&#10;        Material mat = new Material(shader);&#10;        &#10;        // URP uses _BaseColor, Built-in uses _Color&#10;        if (mat.HasProperty(&quot;_BaseColor&quot;))&#10;        {&#10;            mat.SetColor(&quot;_BaseColor&quot;, color);&#10;            Debug.Log(&quot;Set _BaseColor to &quot; + color);&#10;        }&#10;        else if (mat.HasProperty(&quot;_Color&quot;))&#10;        {&#10;            mat.SetColor(&quot;_Color&quot;, color);&#10;            Debug.Log(&quot;Set _Color to &quot; + color);&#10;        }&#10;        else&#10;        {&#10;            mat.color = color;&#10;            Debug.Log(&quot;Set color directly to &quot; + color);&#10;        }&#10;        &#10;        return mat;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>